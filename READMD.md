# Monorepo 实践

本文为学习 monorepo 的一些随笔记录。



## 1、Monorepo 与 Multirepo



### 1-1、Multirepo

 ![](/imgs/img1.png)

多包多仓库的管理方式，也是目前常见的管理方式，每个项目都对应单独的一个代码仓库。

**优点：**

- 各个项目自由度高，可自行选择构建工具、依赖管理、单元测试等配套设施
- 各个项目相对一般相对较小

**缺点：**

- 代码复用问题：在维护多个项目时，可能会涉及公共组件、工具函数，或者一些配置可以复用。你可能会想: 
  - 把代码直接 copy 过来：但有个问题是，如果这些代码出现 bug、或者需要做一些调整的时候，就得修改多个项目下的多份，维护成本越来越高
  - 抽取成独立 npm 包：但是当需要修改这个 npm 包的时候，需要经历 **修改-->发布-->重新再项目中安装**
- 项目基建问题：在 MultiRepo 当中，各个项目的工作流是割裂的，因此每个项目需要单独配置开发环境、配置 CI 流程、配置部署发布流程等等，甚至每个项目都有自己单独的一套脚手架工具



### 1-2、Monorepo

 ![](/imgs/img2.png)

多包单仓库的代码管理方式。目前，很多比较著名的项目都是用的 Monorepo 的方式进行管理，比如：Element-plus、Vue3、React、Babel 等

**优点：**

- 统一工作流：由于所有的项目放在一个仓库当中，复用起来非常方便，如果有依赖的代码变动，那么用到这个依赖的项目当中会立马感知到。并且所有的项目都是使用最新的代码，不会产生其它项目版本更新不及时的情况
- 降低项目基建成本：所有项目复用一套标准的工具和规范、构建、CI/CD 等，无需切换开发环境，如果有新的项目接入，也可以直接复用已有的基建流程
- 方便管理：方便版本管理和依赖管理，模块之间的引用、调试都非常方便

**缺点：**

- 体积问题：所有的项目都在一个 repo 下，那么随着项目的增多，整个 repo 的体积会变得越来越大
- 权限问题：Monorepo 模式下的权限是开放的，所有再这个 Monorepo 里面的项目，每个人都有权利查看



### 1-3、总结思考

上面对比了 Monorepo 与 Multirepo 的项目管理方式，那么什么时候适合使用 Monorepo 呢？

在我看来，最适合使用 Monorepo 进行管理的是：

- 一些第三方库，例如上面提到的 React、Babel 等；
- 各个项目中通用的逻辑方法，可以抽离出来，封装成一个个工具库，这些工具库可以使用 Monorepo 进行管理。
- 各个项目中可复用的业务代码功能，可以抽离出一个业务组件库，每个业务组件是一个 package，那么这些组件 package 也可以通过 Monorepo 进行管理



## 2、Monorepo 的实现方案

Monorepo 项目的基本结构：

```js
├── packages
|   ├── pkg1
|   |   ├── package.json
|   ├── pkg2
|   |   ├── package.json
├── package.json
```

Monorepo 的项目管理，绝不是仅仅代码放到一起就可以的，还需要考虑项目间依赖分析、依赖安装、构建流程、测试流程、CI 及发布流程等诸多工程环节。

目前，比较底层的方案是：lerna 和 yarn 的 workspaces 特性结合，用 yarn 处理依赖问题，lerna 处理发布问题，但是整个构建、测试、CI 等流程还是需要进行手动配置。

当然，也有一些集成的方案，比如[`nx`](https://nx.dev/latest/react/getting-started/getting-started)、[`rushstack`](https://rushstack.io/)，提供从初始化、开发、构建、测试到部署的全流程能力，有一套比较完整的 Monorepo 基础设施，可以直接拿来进行项目的开发。但这些顶层方案内部各种流程和工具链都已经非常完善了，想要基于这些方案来定制、适配和维护的成本过高



接下来，主要以 leran + yarn workspace 的方式学习 monorepo 的管理方式，这也是目前业界最佳实践。









